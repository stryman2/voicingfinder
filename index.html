<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voicing Finder</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* A simple CSS reset for a clean start */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* --- Color Variables --- */
        :root {
            /* Dark Theme Colors */
            --bg-primary: #1E1E1E;
            --bg-secondary: #2D2D35;
            --text-primary: #F8F8F2;
            --text-secondary: #1E1E1E;
            --input-bg: #EEEEEE;
            --muted-gray: #555555;
            --accent-green: #00A67C;
            --accent-green-hover: #008C69;
            --accent-blue: #0A84FF;
            --accent-blue-hover: #0076E5;
            --fretboard-lines: #4A4A4A;
            --note-circle-fill: #F5F5F5;
            --note-text-color: #333333;
            --button-color-special: #8c72ff;
            --button-color-special-hover: #7a63d9;
            --danger-red: #D9534F;
        }

        /* Light Theme Overrides */
        body.light-theme {
            --bg-primary: #f0f0f0;
            --bg-secondary: #ffffff;
            --text-primary: #1E1E1E;
            --text-secondary: #F8F8F2;
            --input-bg: #E0E0E0;
            --muted-gray: #999999;
            --accent-green: #008C69;
            --accent-green-hover: #007A57;
            --accent-blue: #0076E5;
            --accent-blue-hover: #0060B3;
            --fretboard-lines: #B3B3B3;
            --note-circle-fill: #2c2c2c;
            --note-text-color: #F5F5F5;
            --button-color-special: #00BFFF;
            --button-color-special-hover: #009ACD;
            --danger-red: #CC3333;

            input[type="text"], input[type="number"] {
                color: var(--text-primary);
            }
            button::after {
                box-shadow: none;
            }
        }

        body {
            background-color: var(--bg-primary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 24px;
            direction: ltr;
            color: var(--text-primary);
            text-align: left;
            transition: background-color 0.5s ease;
        }

        /* Main container for the app */
        .container {
            background-color: var(--bg-secondary);
            padding: 24px 48px;
            border-radius: 24px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            max-width: 1200px;
            width: 100%;
            text-align: center;
            position: relative;
        }

        /* Theme toggle button */
        #theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: var(--muted-gray);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, color 0.3s;
            z-index: 10;
        }

        #theme-toggle:hover {
            background-color: #666;
        }

        .logo-container {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo-text {
            fill: var(--text-primary);
            font-size: 30px;
            font-weight: 350;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            letter-spacing: -0.5px;
            transition: fill 0.5s ease;
        }

        /* Existing CSS continues here, with updated variables */
        .input-section {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .note-inputs-group, .range-inputs-group {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        label {
            font-weight: 500;
            white-space: nowrap;
        }

        input[type="text"], input[type="number"] {
            padding: 10px;
            border: 1px solid var(--muted-gray);
            border-radius: 8px;
            font-size: 16px;
            width: 100px;
            text-align: center;
            background-color: var(--input-bg);
            color: var(--text-secondary);
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.5s;
        }

        input[type="number"] {
            width: 60px;
        }

        input[type="text"]:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.2);
        }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 30px;
        }

        button {
            width: 290px;
            height: 60px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
            position: relative;
        }

        button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 0 0 rgba(0, 0, 0, 0.2);
            transition: box-shadow 0.2s, transform 0.2s;
        }

        button:active::after {
            transform: translateY(3px);
            box-shadow: 0 2px 0 0 rgba(0, 0, 0, 0.2);
        }

        #find-voicing-strict {
            background-color: var(--accent-green);
        }

        #find-voicing-strict:hover {
            background-color: var(--accent-green-hover);
        }

        #find-voicing-flexible {
            background-color: var(--accent-blue);
        }

        #find-voicing-flexible:hover {
            background-color: var(--accent-blue-hover);
        }

        /* --- NEW: Play/Store Controls --- */
        .play-controls-container {
            display: flex;
            flex-direction: row; /* Changed to row for Play and Store side-by-side */
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            align-items: center;
        }

        .play-controls-container button {
            width: 290px;
            height: 60px;
        }

        #play-voicing-button {
            background-color: var(--button-color-special);
        }

        #play-voicing-button:hover {
            background-color: var(--button-color-special-hover);
        }

        #store-voicing-button {
            background-color: var(--muted-gray);
        }

        #store-voicing-button:hover {
            background-color: #666;
        }
        /* --- END NEW Controls --- */

        .output-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin-bottom: 40px; /* Added margin for separation */
        }

        #fretboard-diagram {
            display: block;
            width: 100%;
            height: 200px;
            background-color: transparent;
            border-radius: 8px;
        }

        #fretboard-diagram text {
            font-size: 16px;
        }

        #fretboard-diagram .fret-line {
            stroke: var(--text-primary);
            transition: stroke 0.5s ease;
        }

        #fretboard-diagram .string-line {
            stroke: var(--text-primary);
            transition: stroke 0.5s ease;
        }

        #fretboard-diagram text {
            fill: var(--text-primary);
            transition: fill 0.5s ease;
        }

        #fretboard-diagram .note-circle {
            fill: var(--note-circle-fill);
            transition: fill 0.5s ease;
        }

        #fretboard-diagram .note-text {
            fill: var(--note-text-color);
            transition: fill 0.5s ease;
        }

        .output-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
        }

        #option-number {
            font-size: 18px;
            font-weight: 600;
        }

        #prev-option, #next-option {
            padding: 8px 15px;
            font-size: 20px;
            background-color: var(--muted-gray);
            color: var(--text-primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s, color 0.3s;
        }

        #prev-option:hover, #next-option:hover {
            background-color: #666;
            transform: none;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }

        /* --- NEW: Saved Voicings Section (The "Store" output) --- */
        .saved-voicings-section {
            width: 100%;
            padding-top: 20px;
            border-top: 1px solid var(--muted-gray);
            text-align: left;
        }

        .saved-voicings-section h3 {
            margin-bottom: 15px;
            font-size: 20px;
            color: var(--text-primary);
        }

        #saved-voicings-container {
            display: flex;
            flex-wrap: wrap; /* Allows items to wrap to the next line */
            gap: 20px;
            justify-content: center; /* Center items when there aren't enough to fill the width */
        }

        .saved-voicing-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-primary);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            width: 200px; /* Fixed width for consistent small display */
        }

        .saved-voicing-item .label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--accent-green);
        }

        .saved-voicing-item svg {
            width: 100%;
            height: 120px; /* Increased height for better visibility */
        }

        .saved-voicing-item .delete-btn {
            background-color: var(--danger-red);
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 5px 10px;
            margin-top: 10px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            height: auto;
        }

        .saved-voicing-item .delete-btn:hover {
            background-color: #A94442;
        }
        
        /* FIX: Override conflicting CSS in saved items */
        .saved-voicing-item svg text {
            font-size: unset !important; 
        }
        /* --- END FIX --- */

        /* --- Media Queries --- */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
             #theme-toggle {
                  width: 35px;
                  height: 35px;
                  font-size: 16px;
                  top: 10px;
                  right: 10px;
    }
            .logo-container svg {
                width: 200px;
                height: auto;
    }

            
            /* FIX: Make Note Inputs Wide and Wrap to two rows */
            .input-section {
                flex-direction: row; 
                flex-wrap: wrap; 
                justify-content: center;
            }

            .note-inputs-group {
                /* Allow input group to wrap for small screens */
                flex-wrap: wrap;
                width: 100%; 
                justify-content: space-between;
                gap: 10px; /* Keep gap clear */
            }

            .note-inputs-group input[type="text"] {
                /* FIX: Set inputs to 45% of container width (two per row) */
                width: 45%; 
                min-width: 100px; 
                font-size: 16px; /* Keep font large for readability */
                padding: 10px;
                /* Overrides the original desktop rule of width: 100px */
            }
            /* --- END INPUT FIX --- */


            .filter-group {
                flex-direction: column; 
                align-items: center;
            }

            .range-inputs-group {
                flex-direction: row;
                justify-content: center;
            }

            input[type="number"] {
                width: 60px;
            }


            .button-container, .play-controls-container {
                flex-direction: column;
                gap: 10px;
            }

            button {
                width: 100%;
                height: 50px;
            }

            #fretboard-diagram {
                height: 150px;
            }

            /* Smaller controls on mobile */
            .play-controls-container {
                flex-direction: column;
            }

            /* Responsive saved items for mobile */
            #saved-voicings-container {
                justify-content: center; /* Center items on mobile */
            }

            .saved-voicing-item {
                width: 90%; /* One item per row on narrow screens for better readability */
                max-width: 300px; /* Optional: prevents it from becoming too wide on tablets */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button id="theme-toggle" aria-label="Toggle theme">
            <i class="fa-solid fa-sun"></i>
        </button>

        <div class="logo-container">
            <svg width="250" height="80" viewBox="0 0 250 80">
                <g transform="translate(40, 40) scale(0.9)">
                    <path d="M 0,-30 C -20,-20 -20,10 0,0" fill="var(--accent-green)" />
                    <path d="M 0,-30 C 20,-20 20,10 0,0" fill="var(--accent-green)" />
                    <g transform="rotate(90)">
                        <path d="M 0,-30 C -20,-20 -20,10 0,0" fill="var(--accent-blue)" />
                        <path d="M 0,-30 C 20,-20 20,10 0,0" fill="var(--accent-blue)" />
                    </g>
                    <g transform="rotate(180)">
                        <path d="M 0,-30 C -20,-20 -20,10 0,0" fill="var(--danger-red)" />
                        <path d="M 0,-30 C 20,-20 20,10 0,0" fill="var(--danger-red)" />
                    </g>
                    <g transform="rotate(270)">
                        <path d="M 0,-30 C -20,-20 -20,10 0,0" fill="var(--button-color-special)" />
                        <path d="M 0,-30 C 20,-20 20,10 0,0" fill="var(--button-color-special)" />
                    </g>
                    <circle cx="0" cy="0" r="8" fill="#8B4513" stroke="#5C3317" stroke-width="2"/>
                </g>
                <text x="160" y="47" class="logo-text" text-anchor="middle">Voicing Finder</text>
            </svg>
        </div>

        <div class="input-section">
            <div class="note-inputs-group">
                <input type="text" id="note1" placeholder="Note 1">
                <input type="text" id="note2" placeholder="Note 2">
                <input type="text" id="note3" placeholder="Note 3">
                <input type="text" id="note4" placeholder="Note 4 (optional)">
            </div>
        </div>

        <div class="input-section">
            <div class="filter-group">
                <label>Fret Range:</label>
                <div class="range-inputs-group">
                    <input type="number" id="minFret" placeholder="Min" value="0" min="0" max="24">
                    <input type="number" id="maxFret" placeholder="Max" value="24" min="0" max="24">
                </div>
            </div>
            <div class="filter-group">
                <label>String Range:</label>
                <div class="range-inputs-group">
                    <input type="number" id="minString" placeholder="Min" value="1" min="1" max="6">
                    <input type="number" id="maxString" placeholder="Max" value="6" min="1" max="6">
                </div>
            </div>
        </div>

        <div class="button-container">
            <button id="find-voicing-strict">Strict Search</button>
            <button id="find-voicing-flexible">Flexible Search</button>
        </div>

        <div class="output-section">
            <svg id="fretboard-diagram"></svg>
            <div class="output-controls">
                <button id="prev-option">&lt;</button>
                <span id="option-number">Enter notes to search</span>
                <button id="next-option">&gt;</button>
            </div>
            <div class="play-controls-container">
                <button id="play-voicing-button">Play Chord</button>
                <button id="store-voicing-button">Store Position</button> </div>
        </div>

        <div class="saved-voicings-section">
            <h3>Saved Voicings</h3>
            <div id="saved-voicings-container">
                </div>
        </div>
        </div>

    <script>
        // JavaScript for the Guitar Voicing Finder
        document.addEventListener('DOMContentLoaded', () => {
            // Select elements from the DOM based on their unique IDs
            const noteInputs = ['note1', 'note2', 'note3', 'note4'].map(id => document.getElementById(id));
            const minFretInput = document.getElementById('minFret');
            const maxFretInput = document.getElementById('maxFret');
            const minStringInput = document.getElementById('minString');
            const maxStringInput = document.getElementById('maxString');

            const findVoicingStrictButton = document.getElementById('find-voicing-strict');
            const findVoicingFlexibleButton = document.getElementById('find-voicing-flexible');
            const playVoicingButton = document.getElementById('play-voicing-button');
            const storeVoicingButton = document.getElementById('store-voicing-button'); // NEW

            const optionNumberElement = document.getElementById('option-number');
            const fretboardSVG = document.getElementById('fretboard-diagram');
            const savedVoicingsContainer = document.getElementById('saved-voicings-container'); // NEW
            const prevButton = document.getElementById('prev-option');
            const nextButton = document.getElementById('next-option');

            let allVoicings = [];
            let currentVoicingIndex = 0;

            // Note frequencies (kept for completeness, though playNote uses calculation)
            const noteFrequencies = {
                'E': [82.41, 164.81, 329.63, 659.26],
                'F': [87.31, 174.61, 349.23, 698.46],
                'F#': [92.50, 185.00, 369.99, 739.99],
                'G': [98.00, 196.00, 392.00, 783.99],
                'G#': [103.83, 207.65, 415.30, 830.61],
                'A': [110.00, 220.00, 440.00, 880.00],
                'A#': [116.54, 233.08, 466.16, 932.33],
                'B': [123.47, 246.94, 493.88, 987.77],
                'C': [130.81, 261.63, 523.25, 1046.50],
                'C#': [138.59, 277.18, 554.37, 1108.73],
                'D': [146.83, 293.66, 587.33, 1174.66],
                'D#': [155.56, 311.13, 622.25, 1244.51]
            };

            // Note to fretboard position map (as provided by user)
            const noteToFretStringMap = {
                'E': [{ fret: 0, string: 6, note: 'E' }, { fret: 7, string: 5, note: 'E' }, { fret: 2, string: 4, note: 'E' }, { fret: 9, string: 3, note: 'E' }, { fret: 5, string: 2, note: 'E' }, { fret: 0, string: 1, note: 'E' }, { fret: 12, string: 6, note: 'E' }, { fret: 14, string: 5, note: 'E' }, { fret: 19, string: 4, note: 'E' }, { fret: 21, string: 3, note: 'E' }, { fret: 17, string: 2, note: 'E' }, { fret: 12, string: 1, note: 'E' }],
                'F': [{ fret: 1, string: 6, note: 'F' }, { fret: 8, string: 5, note: 'F' }, { fret: 3, string: 4, note: 'F' }, { fret: 10, string: 3, note: 'F' }, { fret: 6, string: 2, note: 'F' }, { fret: 1, string: 1, note: 'F' }, { fret: 13, string: 6, note: 'F' }, { fret: 15, string: 5, note: 'F' }, { fret: 20, string: 4, note: 'F' }, { fret: 22, string: 3, note: 'F' }, { fret: 18, string: 2, note: 'F' }, { fret: 13, string: 1, note: 'F' }],
                'F#': [{ fret: 2, string: 6, note: 'F#' }, { fret: 9, string: 5, note: 'F#' }, { fret: 4, string: 4, note: 'F#' }, { fret: 11, string: 3, note: 'F#' }, { fret: 7, string: 2, note: 'F#' }, { fret: 2, string: 1, note: 'F#' }, { fret: 14, string: 6, note: 'F#' }, { fret: 16, string: 5, note: 'F#' }, { fret: 21, string: 4, note: 'F#' }, { fret: 19, string: 2, note: 'F#' }, { fret: 14, string: 1, note: 'F#' }],
                'G': [{ fret: 3, string: 6, note: 'G' }, { fret: 10, string: 5, note: 'G' }, { fret: 5, string: 4, note: 'G' }, { fret: 12, string: 3, note: 'G' }, { fret: 8, string: 2, note: 'G' }, { fret: 3, string: 1, note: 'G' }, { fret: 15, string: 6, note: 'G' }, { fret: 17, string: 5, note: 'G' }, { fret: 22, string: 4, note: 'G' }, { fret: 20, string: 2, note: 'G' }, { fret: 15, string: 1, note: 'G' }],
                'G#': [{ fret: 4, string: 6, note: 'G#' }, { fret: 11, string: 5, note: 'G#' }, { fret: 6, string: 4, note: 'G#' }, { fret: 1, string: 3, note: 'G#' }, { fret: 9, string: 2, note: 'G#' }, { fret: 4, string: 1, note: 'G#' }, { fret: 16, string: 6, note: 'G#' }, { fret: 18, string: 5, note: 'G#' }, { fret: 13, string: 3, note: 'G#' }, { fret: 21, string: 2, note: 'G#' }, { fret: 16, string: 1, note: 'G#' }],
                'A': [{ fret: 5, string: 6, note: 'A' }, { fret: 0, string: 5, note: 'A' }, { fret: 7, string: 4, note: 'A' }, { fret: 2, string: 3, note: 'A' }, { fret: 10, string: 2, note: 'A' }, { fret: 5, string: 1, note: 'A' }, { fret: 17, string: 6, note: 'A' }, { fret: 12, string: 5, note: 'A' }, { fret: 14, string: 4, note: 'A' }, { fret: 19, string: 3, note: 'A' }, { fret: 22, string: 2, note: 'A' }, { fret: 17, string: 1, note: 'A' }],
                'A#': [{ fret: 6, string: 6, note: 'A#' }, { fret: 1, string: 5, note: 'A#' }, { fret: 8, string: 4, note: 'A#' }, { fret: 3, string: 3, note: 'A#' }, { fret: 11, string: 2, note: 'A#' }, { fret: 6, string: 1, note: 'A#' }, { fret: 18, string: 6, note: 'A#' }, { fret: 13, string: 5, note: 'A#' }, { fret: 15, string: 4, note: 'A#' }, { fret: 20, string: 3, note: 'A#' }, { fret: 23, string: 2, note: 'A#' }, { fret: 18, string: 1, note: 'A#' }],
                'B': [{ fret: 7, string: 6, note: 'B' }, { fret: 2, string: 5, note: 'B' }, { fret: 9, string: 4, note: 'B' }, { fret: 4, string: 3, note: 'B' }, { fret: 0, string: 2, note: 'B' }, { fret: 7, string: 1, note: 'B' }, { fret: 19, string: 6, note: 'B' }, { fret: 14, string: 5, note: 'B' }, { fret: 16, string: 4, note: 'B' }, { fret: 21, string: 3, note: 'B' }, { fret: 12, string: 2, note: 'B' }, { fret: 19, string: 1, note: 'B' }],
                'C': [{ fret: 8, string: 6, note: 'C' }, { fret: 3, string: 5, note: 'C' }, { fret: 10, string: 4, note: 'C' }, { fret: 5, string: 3, note: 'C' }, { fret: 1, string: 2, note: 'C' }, { fret: 8, string: 1, note: 'C' }, { fret: 20, string: 6, note: 'C' }, { fret: 15, string: 5, note: 'C' }, { fret: 17, string: 4, note: 'C' }, { fret: 22, string: 3, note: 'C' }, { fret: 13, string: 2, note: 'C' }, { fret: 20, string: 1, note: 'C' }],
                'C#': [{ fret: 9, string: 6, note: 'C#' }, { fret: 4, string: 5, note: 'C#' }, { fret: 11, string: 4, note: 'C#' }, { fret: 6, string: 3, note: 'C#' }, { fret: 2, string: 2, note: 'C#' }, { fret: 9, string: 1, note: 'C#' }, { fret: 21, string: 6, note: 'C#' }, { fret: 16, string: 5, note: 'C#' }, { fret: 18, string: 4, note: 'C#' }, { fret: 23, string: 3, note: 'C#' }, { fret: 14, string: 2, note: 'C#' }, { fret: 21, string: 1, note: 'C#' }],
                'D': [{ fret: 10, string: 6, note: 'D' }, { fret: 5, string: 5, note: 'D' }, { fret: 0, string: 4, note: 'D' }, { fret: 7, string: 3, note: 'D' }, { fret: 3, string: 2, note: 'D' }, { fret: 10, string: 1, note: 'D' }, { fret: 22, string: 6, note: 'D' }, { fret: 17, string: 5, note: 'D' }, { fret: 12, string: 4, note: 'D' }, { fret: 19, string: 3, note: 'D' }, { fret: 15, string: 2, note: 'D' }, { fret: 22, string: 1, note: 'D' }],
                'D#': [{ fret: 11, string: 6, note: 'D#' }, { fret: 6, string: 5, note: 'D#' }, { fret: 1, string: 4, note: 'D#' }, { fret: 8, string: 3, note: 'D#' }, { fret: 4, string: 2, note: 'D#' }, { fret: 11, string: 1, note: 'D#' }, { fret: 23, string: 6, note: 'D#' }, { fret: 18, string: 5, note: 'D#' }, { fret: 13, string: 4, note: 'D#' }, { fret: 20, string: 3, note: 'D#' }, { fret: 16, string: 2, note: 'D#' }, { fret: 23, string: 1, note: 'D#' }]
            };

            /**
             * BUG FIX: Corrects the +1 fret offset error in the source data.
             * This function iterates through the entire note map and decrements each
             * fret value by 1, as required by the technical briefing.
             * @param {object} map The note-to-fret/string map to correct.
             */
            function correctFretMapping(map) {
                // Iterate over each note in the map (e.g., 'E', 'F', 'F#')
                Object.keys(map).forEach(note => {
                    // For each note, iterate over its array of possible positions
                    map[note].forEach(position => {
                        // Decrement the fret value by 1 to fix the offset
                        position.fret -= 1;
                    });
                });
            }

            // Immediately apply the correction to the data map upon script load
            correctFretMapping(noteToFretStringMap);

            // --- Sound Engine (Unchanged) ---
            let audioContext;

            function initAudioContext() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            const stringFrequencies = {
                1: 329.63, 2: 246.94, 3: 196.00, 4: 146.83, 5: 110.00, 6: 82.41
            };

            function playNote(string, fret) {
                if (!audioContext) {
                    initAudioContext();
                }

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                const frequency = stringFrequencies[string] * Math.pow(2, fret / 12);

                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;

                filter.type = 'lowpass';
                filter.frequency.value = 2500;
                filter.Q.value = 1;

                const now = audioContext.currentTime;
                const attackTime = 0.05;
                const decayTime = 0.6
                const sustainLevel = 0.2;
                const releaseTime = 0.7;

                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + attackTime);
                gainNode.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
                gainNode.gain.setValueAtTime(sustainLevel, now + 1);
                gainNode.gain.linearRampToValueAtTime(0, now + 1 + releaseTime);

                oscillator.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(now);
                oscillator.stop(now + 1 + releaseTime + 0.1);
            }

            function playVoicing() {
                const currentVoicing = allVoicings[currentVoicingIndex];
                if (!currentVoicing || currentVoicing.length === 0) {
                    optionNumberElement.textContent = "No chord to play. Find a voicing first.";
                    return;
                }

                initAudioContext();
                currentVoicing.forEach(notePos => {
                    playNote(notePos.string, notePos.fret);
                });
            }

            // --- SVG Drawing Logic (MODIFIED WITH ALL FIXES) ---
            const NUM_FRETS = 24;
            const NUM_STRINGS = 6;
            const MAX_FRET_SPAN = 5;
            const MOBILE_VISIBLE_FRETS = 7;
            
            // **FIX 1: BASE_NOTE_FONT_SIZE increased for better readability**
            const BASE_NOTE_FONT_SIZE_VALUE = 18.0; 

            /**
             * Draws the fretboard structure in SVG.
             * @param {SVGElement} targetSVG - The SVG element to draw into.
             * @param {number} startFret - The fret number to start drawing from.
             * @param {number} numFrets - The number of frets to draw.
             * @param {number} noteRadius - Note circle radius (used for proportional size).
             * @param {number} noteFontSize - Note text font size (used for proportional size).
             * @param {number} fretFontSize - Fret number font size.
             * @param {number} yOffsetMultiplier - Multiplier for the vertical position of fret numbers.
             */
            function drawFretboard(targetSVG, startFret = 0, numFrets = NUM_FRETS, noteRadius = 11.11, noteFontSize = 12.6, fretFontSize = BASE_NOTE_FONT_SIZE_VALUE * 0.9, yOffsetMultiplier = 1.5) {
                targetSVG.innerHTML = '';
                
                // Get dimensions from the ViewBox, not clientWidth/Height, for consistent scaling
                const viewBoxString = targetSVG.getAttribute('viewBox') || `0 0 ${targetSVG.clientWidth} ${targetSVG.clientHeight}`;
                const [, , viewBoxWidth, viewBoxHeight] = viewBoxString.split(' ').map(Number);
                
                const FRETBOARD_WIDTH = viewBoxWidth - 50;
                const FRETBOARD_HEIGHT = viewBoxHeight - 40;
                const FRET_WIDTH = FRETBOARD_WIDTH / numFrets;
                const STRING_HEIGHT = FRETBOARD_HEIGHT / (NUM_STRINGS - 1);
                const FRETBOARD_START_X = 25;
                const FRETBOARD_START_Y = 20;
                
                const CURRENT_FRET_FONT_SIZE = fretFontSize; 

                // Draw strings
                for (let i = 0; i < NUM_STRINGS; i++) {
                    const y = FRETBOARD_START_Y + i * STRING_HEIGHT;
                    targetSVG.innerHTML += `<line x1="${FRETBOARD_START_X}" y1="${y}" x2="${FRETBOARD_START_X + FRETBOARD_WIDTH}" y2="${y}" stroke="var(--text-primary)" stroke-width="1.5" class="string-line" />`;
                    // Draw string number (only for the large diagram)
                    if (targetSVG === fretboardSVG) {
                        targetSVG.innerHTML += `<text x="${FRETBOARD_START_X - 10}" y="${y + noteFontSize * 0.3}" font-size="${noteFontSize}" text-anchor="end" fill="var(--text-primary)">${i + 1}</text>`;
                    }
                }

                // Draw frets and fret numbers
                for (let i = 0; i <= numFrets; i++) {
                    const x = FRETBOARD_START_X + i * FRET_WIDTH;
                    targetSVG.innerHTML += `<line x1="${x}" y1="${FRETBOARD_START_Y}" x2="${x}" y2="${FRETBOARD_START_Y + (NUM_STRINGS - 1) * STRING_HEIGHT}" stroke="var(--text-primary)" stroke-width="1.5" class="fret-line" />`;
                    // Draw fret number
                    if (startFret + i > 0 && (i > 0 || startFret === 0)) {
                        // Use the new yOffsetMultiplier parameter
                        targetSVG.innerHTML += `<text x="${x - FRET_WIDTH / 2}" y="${FRETBOARD_START_Y + (NUM_STRINGS - 1) * STRING_HEIGHT + noteRadius * yOffsetMultiplier}" font-size="${CURRENT_FRET_FONT_SIZE}" text-anchor="middle" fill="var(--text-primary)">${startFret + i}</text>`;
                    }
                }
            }

            /**
             * Draws a given voicing on the fretboard.
             * @param {SVGElement} targetSVG - The SVG element to draw into.
             * @param {Array<Object>} voicing - Array of objects representing finger positions.
             * @param {number} startFret - The fret number to start drawing from (only used for main view).
             */
            function drawVoicing(targetSVG, voicing, startFret = 0) {
                const isMain = targetSVG === fretboardSVG;
                
                const BASE_NOTE_RADIUS = 11.11;
                const BASE_NOTE_FONT_SIZE = BASE_NOTE_FONT_SIZE_VALUE;

                let numFretsToDisplay = isMain ? (window.innerWidth <= 768 ? MOBILE_VISIBLE_FRETS : NUM_FRETS) : MOBILE_VISIBLE_FRETS;

                let noteRadius, noteFontSize, fretFontSize, yOffsetMultiplier;
                
                const minFret = voicing.length > 0 ? Math.min(...voicing.map(note => note.fret)) : 0; 

                // Logic for Small Views (Saved Voicings AND Main View on Mobile)
                if (!isMain || (isMain && window.innerWidth <= 768)) {

                    // **FIX 4: Dynamic Start Fret Logic for small views**
                    if (minFret === 0) {
                        // If the lowest note is Fret 0, start the display from Fret 1 (0 is 'off-board')
                        startFret = 1; 
                    } else {
                        // Otherwise, start the display from the lowest note's fret
                        startFret = minFret;
                    }
                    
                    // Set specific sizes for small/mobile views
                    if (!isMain) {
                        targetSVG.setAttribute('viewBox', '0 0 350 150');
                    }
                    
                    // Sizes for mini diagram
                    noteRadius = BASE_NOTE_RADIUS * 0.7;
                    noteFontSize = BASE_NOTE_FONT_SIZE * 0.7;
                    fretFontSize = BASE_NOTE_FONT_SIZE * 0.9;
                    
                    // **FIX 3: High offset for saved voicings**
                    yOffsetMultiplier = 2.3; 
                    
                } else {
                    // Main diagram sizes (Full desktop view)
                    targetSVG.removeAttribute('viewBox'); 
                    noteRadius = BASE_NOTE_RADIUS;
                    noteFontSize = BASE_NOTE_FONT_SIZE;
                    fretFontSize = BASE_NOTE_FONT_SIZE * 0.9;
                    
                    // **FIX 3: Low offset for the main diagram (default)**
                    yOffsetMultiplier = 1.5; 
                    
                    // Full desktop view starts at 0 always
                    startFret = 0; 
                }
                
                if (isMain && window.innerWidth <= 768) {
                    // Ensure the mobile main view only displays 7 frets
                    numFretsToDisplay = MOBILE_VISIBLE_FRETS;
                }
                
                // Pass all calculated variables, including the new multiplier
                drawFretboard(targetSVG, startFret, numFretsToDisplay, noteRadius, noteFontSize, fretFontSize, yOffsetMultiplier);

                // Re-calculate dimensions based on the VIRTUAL size (ViewBox width/height)
                const viewBoxString = targetSVG.getAttribute('viewBox') || `0 0 ${targetSVG.clientWidth} ${targetSVG.clientHeight}`;
                const [, , viewBoxWidth, viewBoxHeight] = viewBoxString.split(' ').map(Number);
                
                const FRETBOARD_WIDTH = viewBoxWidth - 50;
                const FRETBOARD_HEIGHT = viewBoxHeight - 40;
                const FRET_WIDTH = FRETBOARD_WIDTH / numFretsToDisplay;
                const STRING_HEIGHT = FRETBOARD_HEIGHT / (NUM_STRINGS - 1);
                const FRETBOARD_START_X = 25;
                const FRETBOARD_START_Y = 20;

                voicing.forEach(notePos => {
                    const string = notePos.string;
                    const fret = notePos.fret;
                    const noteName = notePos.originalNote || notePos.note;

                    // Check if the note is within the visible fret range
                    if (fret >= startFret && fret < startFret + numFretsToDisplay) {
                        
                        // **FIX 1: The critical fix for fret position**
                        // Position the note exactly in the center of the fret space
                        const x = FRETBOARD_START_X + (fret - startFret) * FRET_WIDTH + FRET_WIDTH / 2;
                        
                        const y = FRETBOARD_START_Y + (string - 1) * STRING_HEIGHT;

                        // Draw the circle and text with calculated proportional sizes
                        targetSVG.innerHTML += `<circle cx="${x}" cy="${y}" r="${noteRadius}" fill="var(--note-circle-fill)" stroke="transparent" stroke-width="0" class="note-circle" />`;
                        targetSVG.innerHTML += `<text x="${x}" y="${y}" text-anchor="middle" alignment-baseline="central" font-size="${noteFontSize}" fill="var(--note-text-color)" class="note-text">${noteName}</text>`;
                    }
                });
            }

            // ... (Rest of the Voicing Logic - Unchanged) ...
            const flatToSharpMap = { 'DB': 'C#', 'EB': 'D#', 'GB': 'F#', 'AB': 'G#', 'BB': 'A#' };
            function normalizeForSearch(note) { return flatToSharpMap[note.toUpperCase()] || note.toUpperCase(); }

            function sortVoicings(voicings) {
                 // ... (Sorting logic as provided by user) ...
                return voicings.sort((a, b) => {
                    const fretSpanA = Math.max(...a.map(v => v.fret)) - Math.min(...a.map(v => v.fret));
                    const fretSpanB = Math.max(...b.map(v => v.fret)) - Math.min(...b.map(v => v.fret));

                    const sortedStringsA = a.map(v => v.string).sort((s1, s2) => s1 - s2);
                    let jumpsA = 0;
                    for (let i = 1; i < sortedStringsA.length; i++) {
                        if (sortedStringsA[i] - sortedStringsA[i-1] > 1) { jumpsA++; }
                    }

                    const sortedStringsB = b.map(v => v.string).sort((s1, s2) => s1 - s2);
                    let jumpsB = 0;
                    for (let i = 1; i < sortedStringsB.length; i++) {
                        if (sortedStringsB[i] - sortedStringsB[i-1] > 1) { jumpsB++; }
                    }

                    if (jumpsA === 0 && jumpsB > 0) return -1;
                    if (jumpsA > 0 && jumpsB === 0) return 1;

                    if (fretSpanA !== fretSpanB) {
                        return fretSpanA - fretSpanB;
                    }

                    return jumpsA - jumpsB;
                });
            }

            function getPermutations(arr) {
                const result = [];
                if (arr.length === 0) return [[]];
                if (arr.length === 1) return [arr];

                for (let i = 0; i < arr.length; i++) {
                    const firstElement = arr[i];
                    const remainingElements = arr.slice(0, i).concat(arr.slice(i + 1));
                    const remainingPermutations = getPermutations(remainingElements);

                    for (let j = 0; j < remainingPermutations.length; j++) {
                        result.push([firstElement].concat(remainingPermutations[j]));
                    }
                }
                return result;
            }

            function findVoicingsRecursiveStrict(notes, currentVoicing, usedStrings, allVoicings, noteIndex, minString, maxString) {
                if (noteIndex === notes.length) {
                    allVoicings.push([...currentVoicing]);
                    return;
                }

                const originalNote = notes[noteIndex];
                const noteToFind = normalizeForSearch(originalNote);
                const possiblePositions = noteToFretStringMap[noteToFind];

                if (!possiblePositions) return;

                for (const pos of possiblePositions) {
                    if (pos.string >= minString && pos.string <= maxString) {
                        if (!usedStrings.has(pos.string)) {
                            if (noteIndex === 0 || pos.string < currentVoicing[currentVoicing.length - 1].string) {
                                usedStrings.add(pos.string);
                                const newVoicing = [...currentVoicing, { ...pos, originalNote: originalNote }];
                                findVoicingsRecursiveStrict(notes, newVoicing, usedStrings, allVoicings, noteIndex + 1, minString, maxString);
                                usedStrings.delete(pos.string);
                            }
                        }
                    }
                }
            }

            function getUniqueVoicings(foundVoicings, minFret, maxFret) {
                const uniqueVoicings = [];
                const uniqueKeys = new Set();
                foundVoicings.forEach(voicing => {
                    const frets = voicing.map(v => v.fret);
                    const minVoicingFret = Math.min(...frets);
                    const maxVoicingFret = Math.max(...frets);
                    const fretSpan = maxVoicingFret - minVoicingFret;

                    if (minVoicingFret >= minFret && maxVoicingFret <= maxFret && fretSpan <= MAX_FRET_SPAN) {
                        const sortedVoicing = [...voicing].sort((a, b) => a.string - b.string);
                        const voicingKey = JSON.stringify(sortedVoicing.map(v => ({ fret: v.fret, string: v.string })));
                        if (!uniqueKeys.has(voicingKey)) {
                            uniqueKeys.add(voicingKey);
                            uniqueVoicings.push(voicing);
                        }
                    }
                });
                return uniqueVoicings;
            }

            function findAndFilterVoicingsStrict() {
                const inputNotes = noteInputs.map(input => input.value).filter(note => note.trim() !== '');
                if (inputNotes.length === 0) return [];

                const minString = parseInt(minStringInput.value, 10) || 1;
                const maxString = parseInt(maxStringInput.value, 10) || 6;
                const minFret = parseInt(minFretInput.value, 10) || 0;
                const maxFret = parseInt(maxFretInput.value, 10) || 24;

                const foundVoicings = [];
                const usedStrings = new Set();
                findVoicingsRecursiveStrict(inputNotes, [], usedStrings, foundVoicings, 0, minString, maxString);

                const uniqueVoicings = getUniqueVoicings(foundVoicings, minFret, maxFret);
                return sortVoicings(uniqueVoicings);
            }

            function findAndFilterVoicingsFlexible() {
                const inputNotes = noteInputs.map(input => input.value).filter(note => note.trim() !== '');
                if (inputNotes.length === 0) return [];

                const minString = parseInt(minStringInput.value, 10) || 1;
                const maxString = parseInt(maxStringInput.value, 10) || 6;
                const minFret = parseInt(minFretInput.value, 10) || 0;
                const maxFret = parseInt(maxFretInput.value, 10) || 24;

                const allVoicings = [];
                const notePermutations = getPermutations(inputNotes);

                notePermutations.forEach(permutation => {
                    const foundVoicings = [];
                    const usedStrings = new Set();
                    findVoicingsRecursiveStrict(permutation, [], usedStrings, foundVoicings, 0, minString, maxString);
                    allVoicings.push(...foundVoicings);
                });

                const uniqueVoicings = getUniqueVoicings(allVoicings, minFret, maxFret);
                return sortVoicings(uniqueVoicings);
            }

            function displayCurrentVoicing() {
                if (allVoicings.length > 0) {
                    const voicing = allVoicings[currentVoicingIndex];

                    // startFret is now handled entirely inside drawVoicing for consistency
                    drawVoicing(fretboardSVG, voicing, 0); 
                    
                    optionNumberElement.textContent = `Option ${currentVoicingIndex + 1} of ${allVoicings.length}`;
                    prevButton.disabled = currentVoicingIndex === 0;
                    nextButton.disabled = allVoicings.length === 0 || currentVoicingIndex === allVoicings.length - 1;
                    playVoicingButton.disabled = false;
                    storeVoicingButton.disabled = false; // Enable store button
                } else {
                    let numFretsToDisplay = NUM_FRETS;
                    if (window.innerWidth <= 768) {
                        numFretsToDisplay = MOBILE_VISIBLE_FRETS;
                    }
                    // Reset main diagram to empty state
                    fretboardSVG.removeAttribute('viewBox'); // Reset ViewBox for main diagram
                    drawVoicing(fretboardSVG, [], 0); // Pass the main SVG element, draw empty
                    optionNumberElement.textContent = "No voicings found.";
                    prevButton.disabled = true;
                    nextButton.disabled = true;
                    playVoicingButton.disabled = true;
                    storeVoicingButton.disabled = true; // Disable store button
                }
            }

            // --- NEW: Saved Voicings Logic (Unchanged) ---

            /**
             * Loads saved voicings from localStorage.
             * @returns {Array<Object>}
             */
            function loadSavedVoicings() {
                try {
                    const saved = localStorage.getItem('savedGuitarVoicings');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) {
                    console.error("Could not load saved voicings:", e);
                    return [];
                }
            }

            /**
             * Saves a voicing to localStorage.
             * @param {Array<Object>} voicing - The voicing to save.
             */
            function saveVoicing(voicing) {
                const savedVoicings = loadSavedVoicings();

                // Prevent saving duplicates (based on fret/string position)
                const newVoicingKey = JSON.stringify(voicing.map(v => ({ fret: v.fret, string: v.string })));
                const isDuplicate = savedVoicings.some(savedV => {
                    const savedVoicingKey = JSON.stringify(savedV.voicing.map(v => ({ fret: v.fret, string: v.string })));
                    return savedVoicingKey === newVoicingKey;
                });

                if (isDuplicate) {
                    // Optional: Show a temporary message that it's already saved
                    storeVoicingButton.textContent = "Already Saved!";
                    setTimeout(() => storeVoicingButton.textContent = "Store Position", 1500);
                    return;
                }

                // Voicing object structure: { id, label, voicing }
                const newVoicing = {
                    id: Date.now(),
                    label: voicing.map(v => v.originalNote || v.note).join('-'), // A label for display
                    voicing: voicing
                };

                savedVoicings.push(newVoicing);

                try {
                    localStorage.setItem('savedGuitarVoicings', JSON.stringify(savedVoicings));
                    renderSavedVoicings();
                    storeVoicingButton.textContent = "Saved!";
                    setTimeout(() => storeVoicingButton.textContent = "Store Position", 1500);
                } catch (e) {
                    console.error("Could not save voicing:", e);
                }
            }

            /**
             * Deletes a saved voicing by its ID.
             * @param {number} id - The ID of the voicing to delete.
             */
            function deleteVoicing(id) {
                 let savedVoicings = loadSavedVoicings();
                 savedVoicings = savedVoicings.filter(v => v.id !== id);
                 localStorage.setItem('savedGuitarVoicings', JSON.stringify(savedVoicings));
                 renderSavedVoicings();
            }


            /**
             * Renders all saved voicings in the container.
             */
            function renderSavedVoicings() {
                savedVoicingsContainer.innerHTML = ''; // Clear existing
                const savedVoicings = loadSavedVoicings();

                savedVoicings.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'saved-voicing-item';
                    itemDiv.dataset.id = item.id;

                    // Label/Name
                    itemDiv.innerHTML += `<span class="label">${item.label.replace(/-/g, '•')}</span>`; // Use bullet point for better separation

                    // SVG Diagram (Mini Fretboard)
                    const miniSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    // We set the ViewBox inside drawVoicing for calculated scaling
                    miniSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

                    // The trick: drawVoicing draws into the miniSvg element
                    drawVoicing(miniSvg, item.voicing);

                    itemDiv.appendChild(miniSvg);

                    // Delete Button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = 'Remove';
                    deleteBtn.addEventListener('click', () => deleteVoicing(item.id));
                    itemDiv.appendChild(deleteBtn);

                    savedVoicingsContainer.appendChild(itemDiv);
                });
            }

            // --- Theme Toggle Functionality (Unchanged) ---
            const themeToggleBtn = document.getElementById('theme-toggle');
            const themeIcon = themeToggleBtn.querySelector('i');
            const body = document.body;

            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                body.classList.add(savedTheme);
                if (savedTheme === 'light-theme') {
                    themeIcon.classList.replace('fa-sun', 'fa-moon');
                }
            }

            themeToggleBtn.addEventListener('click', () => {
                if (body.classList.contains('light-theme')) {
                    body.classList.remove('light-theme');
                    localStorage.setItem('theme', 'dark-theme');
                    themeIcon.classList.replace('fa-moon', 'fa-sun');
                } else {
                    body.classList.add('light-theme');
                    localStorage.setItem('theme', 'light-theme');
                    themeIcon.classList.replace('fa-sun', 'fa-moon');
                }
                displayCurrentVoicing();
                renderSavedVoicings(); // Re-render saved voicings to apply new theme colors
            });

            // Event Listeners
            findVoicingStrictButton.addEventListener('click', () => {
                allVoicings = findAndFilterVoicingsStrict();
                currentVoicingIndex = 0;
                displayCurrentVoicing();
            });

            findVoicingFlexibleButton.addEventListener('click', () => {
                allVoicings = findAndFilterVoicingsFlexible();
                currentVoicingIndex = 0;
                displayCurrentVoicing();
            });

            // NEW: Store Button Event Listener
            storeVoicingButton.addEventListener('click', () => {
                if (allVoicings.length > 0) {
                    saveVoicing(allVoicings[currentVoicingIndex]);
                }
            });

            prevButton.addEventListener('click', () => {
                if (currentVoicingIndex > 0) {
                    currentVoicingIndex--;
                    displayCurrentVoicing();
                }
            });

            nextButton.addEventListener('click', () => {
                if (currentVoicingIndex < allVoicings.length - 1) {
                    currentVoicingIndex++;
                    displayCurrentVoicing();
                }
            });

            playVoicingButton.addEventListener('click', playVoicing);
            window.addEventListener('resize', displayCurrentVoicing);

            // Initial drawing and loading
            displayCurrentVoicing();
            renderSavedVoicings(); // Load and display saved items on startup
        });
    </script>
</body>
</html>